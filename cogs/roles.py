import asyncio
import json
import logging
from datetime import datetime

import discord
from discord.ext import commands

import database as db
from models.modMember import get_mod_member


class Roles(commands.Cog):
    FIELDNAMES = {
        "Prof": "DM_choice_categories",
        "Élève G1": "DM_choice_roles_G1",
        "Élève G2": "DM_choice_roles_G2",
    }

    def __init__(self, bot):
        self.bot = bot

        with open("static/json/reacts_pairs.json", encoding="utf-8") as f:
            self.reacts_pairs = json.load(f)

    async def send_choice(self, ctx, name):
        """Generate a welcome message to choice roles to manage permissions"""

        with open(f"static/txt/{name}.txt", encoding="utf-8") as content:
            embed = discord.Embed(
                title="Bienvenue!", colour=0xFF22FF, description=content.read()
            )
            embed.set_thumbnail(url=ctx.guild.icon_url)
            embed.set_footer(
                text=f"Generated by {self.bot.user.name} | {datetime.now():%D - %H:%M}"
            )
            message = await ctx.send(embed=embed)

        for reaction in self.reacts_pairs[name]:
            await message.add_reaction(reaction)

        return message

    @commands.command(name="guild_choice", hidden=True)
    @commands.is_owner()
    async def send_guild_choice(self, ctx):
        """ Generate a welcome message to choice roles to manage permissions """
        await ctx.message.delete()
        message = await self.send_choice(ctx, "guild_choice")
        sql = (
            f"UPDATE specials SET choice_msg_id={message.id}"
            f"WHERE name='guild_choice'"
        )
        db.execute(sql)

    @commands.Cog.listener("on_raw_reaction_add")
    @commands.guild_only()
    async def reaction_guild_choice(self, payload):
        """ Called when a user add a reaction """
        sql = "SELECT message_id FROM specials WHERE name='guild_choice'"
        (choice_msg_id,) = db.execute(sql, fetchone=True)
        if choice_msg_id != payload.message_id or self.bot.user.id == payload.user_id:
            return  # exit if it's not for the guild_choice message

        mod_member = get_mod_member(self.bot, payload.member)
        try:
            role_name = self.reacts_pairs["guild_choice"][payload.emoji.name]
            await mod_member.update_top_role(role_name)
        except KeyError:
            await mod_member.dm_channel.send(
                f"{mod_member.mention} Cette réaction est invalide"
            )
        except AttributeError:
            logging.error(
                f"The user {mod_member.name} was not registered in members table"
            )
        else:
            fieldname = self.FIELDNAMES.get(mod_member.top_role.name)
            message = await self.send_choice(mod_member, fieldname)
            # delete all sub roles if the user already choice in the past
            mod_member.update_db(sub_roles="", choice_msg_id=message.id)

    @commands.Cog.listener("on_raw_reaction_add")
    @commands.Cog.listener("on_raw_reaction_remove")
    @commands.dm_only()
    async def reaction_sub_role_add(self, payload):
        """ React when a member choice his roles  in DM channel """
        mod_member = get_mod_member(self.bot, payload.user_id)

        if mod_member and payload.message_id == mod_member.dm_choice_msg_id:
            if mod_member.validate_state == 2:
                await mod_member.send(
                    "Vous ne pouvez plus redéfinir vos choix, veuillez contacter un modérateur."
                )
                return
        else:
            return

        fieldname = self.FIELDNAMES.get(mod_member.top_role.name)
        try:
            emoji_value = self.reacts_pairs[fieldname][payload.emoji.name]
        except KeyError:
            await mod_member.send("Cette réaction est invalide")
            return

        if payload.event_type == "REACTION_ADD":
            mod_member.sub_roles.add(emoji_value)
        else:
            mod_member.sub_roles.remove(emoji_value)

        if mod_member.validate_state == 0:
            await self.send_sub_roles_validate(mod_member)

    async def send_sub_roles_validate(self, mod_member):
        """ Update sub roles list in json file """
        embed = discord.Embed(
            title="Confirmation",
            colour=0xFF22FF,
            description="Voulez-vous valider votre sélection?",
        )
        embed.set_footer(text="This message will be disappear in 60 seconds.")
        message = await mod_member.send(embed=embed)
        await message.add_reaction("✅")
        await message.add_reaction("❌")
        mod_member.update_db(validate_state=1)

        def check(react, usr):
            if react.message.id == message.id and mod_member.id == usr.id:
                return str(react.emoji) == "✅" or str(react.emoji) == "❌"

        try:
            reaction, user = await self.bot.wait_for(
                "reaction_add", timeout=60.0, check=check
            )
        except asyncio.TimeoutError:
            await mod_member.send("Le délai de confirmaton a expiré")
            mod_member.update_db(validate_state=0)
        else:
            if str(reaction.emoji) == "✅":
                await mod_member.member.add_roles(
                    mod_member.sub_roles, reason="The member has selected this matter"
                )
                embed = discord.Embed(
                    title=f"Vous êtes 'fin prêt, cher {mod_member.main_role}!",
                    colour=0xFF22FF,
                    description="Vos choix ont été pris en compte, vous devez avoir à"
                    "présent accès aux salons!",
                )
                await mod_member.send(embed=embed)
                mod_member.update_db(validate_state=2)
            else:
                mod_member.update_db(validate_state=0)
                await mod_member.send("Vos choix ont été déclinés.")
        finally:
            await message.delete()


def setup(bot):
    bot.add_cog(Roles(bot))
